package core.text{	import flash.text.TextFormat;	import flash.utils.ByteArray;	import flash.utils.Dictionary;
		public class Style extends TextFormat  {		private static var _data:XML = new XML();				private var _node:XML;		private var _fontBold:String = "";				private var _invalidProperties:Array = ["font", "name", "TextField", "fontBold"];		private var _fonts:Dictionary;						public static function extend(value:XML):void		{			var tempData:XML = new XML(value);			if (_data.Default.length() > 0) delete _data.Default;						_data = new XML('<Styles>' + _data.children().toString() + tempData.children().toString() + '</Styles>');		}				public static function require(EmbeddedReference:Class):void		{			var file:ByteArray = new EmbeddedReference();			var xmlData:String = file.readUTFBytes(file.length);			extend(new XML(xmlData));		}						public static function get data():XML { return _data; }		public static function get ready():Boolean		{			return(String(_data).length > 10);		}						public function set fontBold(val:String):void { _fontBold = val; }		public function get fontBold():String         { return _fontBold; }		public function get node():XML                { return _node; }								public function Style(name:String = "") {			super();						var fontObject:Object;			var styleNode:XML;						_fonts = new Dictionary();			// GET ALL FONT DEFINITIONS						for each (styleNode in _data.Fonts.Font) {				fontObject = {};				fontObject.font  = String(styleNode.font);				fontObject.key   = String(styleNode.name);				fontObject.node  = styleNode;								_fonts[fontObject.key] = fontObject;			}									// DEFAULT FONT						_node = new XML(_data.Default);			setFormat(_node);						var styleName:String;						for each (styleNode in _data.Style)			{				styleName = styleNode.name;				while (styleName.indexOf(', ') > 0) styleName = styleName.replace(/, /gi, ',');								if (styleName.split(',').indexOf(name) != -1)				{					_node = new XML(styleNode);										if (_data.child(String(_node.font) + 'Default').length() > 0)					{						// FONT SPECIFIC DEFAULT FORMAT						setFormat(new XML(_data.child(String(_node.font) + 'Default')));					}										setFormat(styleNode);				}			}					}								private function isSecure(propertyName:String):Boolean		{			if(_invalidProperties.indexOf(propertyName) >= 0) return false;			else return true;		}				private function setProp(prop:XML):void		{			if (isSecure(String(prop.name())))			{				switch(String(prop.name()))				{					case 'bold': this[String(prop.name())] = (String(prop) == 'true' ? true : false); break;					default: this[String(prop.name())] = prop; break;				}			}		}						private function setFormat(styleNode:XML):void {			for each (var prop:XML in styleNode.children())			{				if (String(prop.name()) == "font")     setFont(String(prop));				if (String(prop.name()) == "fontBold") _fontBold = String(_fonts[String(prop)].font);								setProp(prop);			}		}						private function setFont(fontKey:String):void {			if(_fonts[fontKey] == null) return;						for each (var prop:XML in XML(_fonts[fontKey].node).children())			{				setProp(prop);			}						this.font = _fonts[fontKey].font;		}	}	}